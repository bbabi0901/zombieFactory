const truffleAssert = require("truffle-assertions");

const Factory = artifacts.require("ZombieFactory");
const ZombieTemp = artifacts.require("ZombieTemp");
const Zombie = artifacts.require("Zombie");

const {
  catchRevert,
  createAddress2,
  nameToSalt,
  encodeParams,
} = require("./utils/utils.js");

contract("ZombieFactory", async (accounts) => {
  // bytecode는 to-be-deployed contract의 bytecode
  const {
    bytecode: zombieBytecode,
  } = require("../artifacts/contracts/Zombie.sol/Zombie.json");
  const name1 = "Gildong";
  const name2 = "Chulsoo";

  before(async () => {
    zombieFactory = await Factory.new({ from: accounts[0] });
    console.log("Deployed Factory: ", zombieFactory.address);

    zombieTemp = await ZombieTemp.new({ from: accounts[0] });
    console.log("Deployed ZombieTemp: ", zombieTemp.address);
  });

  describe("Zombie generated by 'create'", () => {
    it("두 좀비의 주소가 달라야 합니다.", async () => {
      let tx = await zombieFactory.createRandomZombie(name1);
      var { zombie, dna } = tx.logs[0].args;
      const zombie1Addr = zombie;
      const zombie1 = await Zombie.at(zombie1Addr);
      let name = await zombie1.name();

      tx = await zombieFactory.createRandomZombie(name2);
      var { zombie, dna } = tx.logs[0].args;
      const zombie2Addr = zombie;
      const zombie2 = await Zombie.at(zombie2Addr);
      name = await zombie2.name();

      await assert.notStrictEqual(zombie1Addr, zombie2Addr);
    });
  });

  describe("Zombie generated by 'create2'", () => {
    let tx, zombie1Addr, name, zombieDNA, zombie1;

    beforeEach(async () => {
      tx = await zombieFactory.createRandomZombieV2(name1);
      var { zombie, dna } = tx.logs[0].args;
      zombie1Addr = zombie;
      zombie1 = await Zombie.at(zombie1Addr);
      name = await zombie1.name();
      zombieDNA = +dna;
    });

    afterEach(async () => {
      zombie1 = await Zombie.at(zombie1Addr);
      truffleAssert.passes(await zombie1.destroy(accounts[0]));
    });

    it("이름이 같은 좀비를 생성시 실패해야 합니다.", async () => {
      const errMessage =
        "Returned error: VM Exception while processing transaction: revert without reason string";
      await catchRevert(zombieFactory.createRandomZombieV2(name1), errMessage);
    });

    it("좀비의 주소가 오프체인에서 특정한 주소와 같아야 합니다.", async () => {
      console.log("created2", zombie1.address);
      dna = +(await zombie1.dna());
      dnaString = dna.toString();
      name = await zombie1.name();

      const params = encodeParams(["string", "uint"], [name, dnaString]);

      const bytecode = `${zombieBytecode}${params.slice(2)}`;
      const bytecodeFromContract = await zombieFactory.getBytecode(name, dna);
      assert.equal(bytecodeFromContract, bytecode, "bytecode differs ");

      const salt = nameToSalt(name1);
      assert.equal(await zombieFactory.getSalt(name), salt, "salt differs");

      const computeAddr = createAddress2(zombieFactory.address, name, bytecode);
      assert.equal(zombie1Addr.toLowerCase(), computeAddr, "addr differs");
    });

    it("이름이 다른 두 좀비의 주소가 달라야 합니다.", async () => {
      const tx = await zombieFactory.createRandomZombieV2(name2);
      var { zombie, dna } = tx.logs[0].args;
      let zombie2Addr = zombie;
      let zombie2 = await Zombie.at(zombie2Addr);
      name = await zombie2.name();
      assert.strictEqual(name, name2);
      assert.notStrictEqual(zombie1Addr, zombie2Addr);
    });
  });

  describe("Modifying state with delegatecall", () => {
    let tx, zombie1Addr, name, zombieDNA, zombie1;
    const dnaModified = 12345678;

    beforeEach(async () => {
      tx = await zombieFactory.createRandomZombie(name1);
      var { zombie, dna } = tx.logs[0].args;
      zombie1Addr = zombie;
      zombie1 = await Zombie.at(zombie1Addr);
      name = await zombie1.name();
      zombieDNA = +dna;
    });

    it("setDNA로 변경시 Zombie contract의 상태가 바뀌어야 합니다.", async () => {
      const res = await zombie1.setDNA(zombieTemp.address, dnaModified);

      dna = await zombie1.dna();

      assert.strictEqual(+dna, dnaModified, `DNA should be ${dnaModified}`);
    });

    it("setDNA로 변경시 ZombieTemp contract의 상태가 바뀌지 않아야 합니다.", async () => {
      const res = await zombie1.setDNA(zombieTemp.address, dnaModified);
      dna = await zombieTemp.dna();
      console.log("dna state of zombieTemp contract", +dna);
      assert.notStrictEqual(
        +dna,
        dnaModified,
        `DNA should not be ${dnaModified}`
      );
    });
  });

  describe("Staticcall", () => {
    let tx, zombie1Addr, name, zombieDNA, zombie1;
    const dnaModified = 12345678;
    beforeEach(async () => {
      tx = await zombieFactory.createRandomZombie(name1);
      var { zombie, dna } = tx.logs[0].args;
      zombie1Addr = zombie;
      zombie1 = await Zombie.at(zombie1Addr);
      name = await zombie1.name();
      zombieDNA = +dna;
    });
    it("staticcall로 state 변경하려고 하면?", async () => {
      const res = await zombie1.setDNAbyStaticcall(
        zombieTemp.address,
        dnaModified
      );
      // staticcall은 call처럼 zombieTemp의 상태변수를 바꿔야한다.
      dna = await zombieTemp.dna();
      console.log("dna state of zombieTemp contract", +dna);
      assert.notStrictEqual(
        +dna,
        dnaModified,
        `DNA should not be ${dnaModified}`
      );
    });
  });
});
